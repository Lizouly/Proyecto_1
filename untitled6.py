# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-4yP8HOQGTloTwUblq8PEqJwCQMzmDpC
"""

# Importar bibliotecas necesarias
import numpy as np
import pandas as pd
from google.colab import files

# Subir el archivo desde la computadora local
uploaded = files.upload()

# Leer el archivo Excel
data = pd.read_excel('Web.xlsx', sheet_name='Hoja1')

# Definir la clase base Grafica
class Grafica:
    def __init__(self, nodos, enlaces):
        """
        Inicializa la clase base Grafica con un conjunto de nodos y enlaces.
        :param nodos: lista de nodos (páginas web)
        :param enlaces: lista de tuplas (i, j) donde j es citado por i.
        """
        self.nodos = nodos
        self.enlaces = enlaces
        self.n = len(nodos)

    def obtener_matriz_enlaces(self):
        """
        Crea la matriz de adyacencia P, que representa las probabilidades de transitar de un nodo a otro.
        :return: Matriz de adyacencia P
        """
        P = np.zeros((self.n, self.n))
        # Contamos el número de enlaces salientes de cada página
        salientes = {i: 0 for i in range(self.n)}
        for (i, j) in self.enlaces:
            salientes[j] += 1

        # Llenamos la matriz de enlaces
        for (i, j) in self.enlaces:
            P[i, j] = 1 / salientes[j]  # Normalizamos el enlace

        return P

# Definir la clase Red que hereda de Grafica
class Red(Grafica):
    def __init__(self, nodos, enlaces):
        super().__init__(nodos, enlaces)
        self.P = self.obtener_matriz_enlaces()

    def pagerank(self, d=0.85, max_iter=100, tol=1e-6):
        """
        Calcula el vector de PageRank utilizando la ecuación iterativa.
        :param d: Factor de amortiguamiento.
        :param max_iter: Número máximo de iteraciones.
        :param tol: Tolerancia para la convergencia.
        :return: El vector de PageRank
        """
        # Matriz de teletransporte U, que distribuye uniformemente la probabilidad entre todas las páginas
        U = np.ones(self.n) / self.n
        # Inicializamos el vector π con un valor uniforme
        pi = np.ones(self.n) / self.n
        # Iteramos hasta la convergencia
        for _ in range(max_iter):
            # Realizamos la multiplicación matricial correctamente
            pi_new = d * np.dot(self.P, pi) + (1 - d) * U
            # Chequeamos la convergencia
            if np.linalg.norm(pi_new - pi, 1) < tol:
                break
            pi = pi_new
        return pi

# Preparar nodos (páginas) y enlaces (citas)
nodos = data['Website'].tolist()
enlaces = []

for idx, row in data.iterrows():
    cited_by = [int(x) - 1 for x in row['Cited by'].split(',')]  # Convertimos índices a 0-based
    for c in cited_by:
        enlaces.append((idx, c))  # El índice 'idx' es citado por el índice 'c'

# Crear la red
red = Red(nodos, enlaces)

# Calcular el PageRank
pagerank_result = red.pagerank(d=0.85)

# Mostrar el resultado
for node, pr in zip(nodos, pagerank_result):
    print(f"PageRank de {node}: {pr:.4f}")

# Paso 1: Identificar las páginas con terminación '.ru'
def actualizar_vector_pi(nodos):
    s = sum([1 for nodo in nodos if nodo.endswith('.ru')])  # Contamos las páginas con '.ru'

    # Paso 2: Crear el nuevo vector π
    pi = np.zeros(len(nodos))  # Inicializamos el vector π con ceros
    for i, nodo in enumerate(nodos):
        if nodo.endswith('.ru'):
            pi[i] = 1 / s  # Asignamos 1/s a las páginas con '.ru'

    return pi

# Paso 3: Usamos esta función para actualizar el vector π
pi_ru = actualizar_vector_pi(nodos)

# Mostrar el vector actualizado
for nodo, valor in zip(nodos, pi_ru):
    print(f"π para {nodo}: {valor:.4f}")

# Función de PageRank con amortiguamiento y teletransporte
def pagerank_con_teletransporte(P, d=0.85, max_iter=100, tol=1e-6):
    n = P.shape[0]

    # Matriz de teletransporte U, con 1/n en todas las entradas
    U = np.ones(n) / n

    # Inicializamos el vector π con un valor uniforme
    pi = np.ones(n) / n

    # Iteramos hasta la convergencia
    for _ in range(max_iter):
        pi_new = d * np.dot(P, pi) + (1 - d) * U
        if np.linalg.norm(pi_new - pi, 1) < tol:
            break
        pi = pi_new

    return pi

# Ahora vamos a calcular el PageRank para los tres valores de d
for d in [0.5, 0.85, 1.0]:
    pi_d = pagerank_con_teletransporte(red.P, d=d)
    print(f"\nPageRank con d={d}:")
    for nodo, valor in zip(nodos, pi_d):
        print(f"π para {nodo}: {valor:.4f}")

#CODIGO YA CORREGIDO#

# Importar bibliotecas necesarias
import numpy as np
import pandas as pd
from google.colab import files

# Subir el archivo desde la computadora local
uploaded = files.upload()

# Leer el archivo Excel
data = pd.read_excel('Web.xlsx', sheet_name='Hoja1')

import numpy as np
import pandas as pd

class Grafica:
    def __init__(self, nodos, enlaces):
        """
        Inicializa la clase base Grafica con un conjunto de nodos y enlaces.
        :param nodos: lista de nodos (páginas web).
        :param enlaces: lista de tuplas (i, j) donde j es citado por i.
        """
        self.nodos = nodos
        self.enlaces = enlaces
        self.n = len(nodos)

    def obtener_matriz_enlaces(self):
        """
        Crea la matriz de adyacencia P, que representa las probabilidades de transitar de un nodo a otro.
        :return: Matriz de adyacencia P.
        """
        P = np.zeros((self.n, self.n))
        # Contamos el número de enlaces salientes de cada página
        salientes = {i: 0 for i in range(self.n)}
        for (i, j) in self.enlaces:
            salientes[j] += 1

        # Llenamos la matriz de enlaces
        for (i, j) in self.enlaces:
            P[i, j] = 1 / salientes[j]  # Normalizamos el enlace

        return P

class Red(Grafica):
    def __init__(self, nodos, enlaces):
        super().__init__(nodos, enlaces)
        self.P = self.obtener_matriz_enlaces()

def pagerank_con_teletransporte(P, d=0.85, max_iter=100, tol=1e-6):
    """
    Calcula el vector de PageRank utilizando la ecuación iterativa con teletransporte.
    :param P: Matriz de transición (enlaces entre páginas).
    :param d: Factor de amortiguamiento.
    :param max_iter: Número máximo de iteraciones.
    :param tol: Tolerancia para la convergencia.
    :return: El vector de PageRank.
    """
    n = P.shape[0]
    U = np.ones(n) / n  # Matriz de teletransporte
    pi = np.ones(n) / n  # Vector inicial uniformemente distribuido

    for _ in range(max_iter):
        pi_new = d * np.dot(P, pi) + (1 - d) * U
        if np.linalg.norm(pi_new - pi, 1) < tol:
            break
        pi = pi_new

    return pi

def actualizar_vector_pi(nodos):
    """
    Ajusta el vector inicial π para las páginas con terminación .ru.
    :param nodos: Lista de nombres de nodos (páginas).
    :return: Vector inicial π ajustado.
    """
    s = sum(1 for nodo in nodos if nodo.endswith('.ru'))  # Contamos las páginas con '.ru'
    pi = np.zeros(len(nodos))
    for i, nodo in enumerate(nodos):
        if nodo.endswith('.ru'):
            pi[i] = 1 / s  # Asignamos 1/s a las páginas con '.ru'
    return pi

if __name__ == "__main__":
    # Cargar el archivo Excel
    file_name = 'Web.xlsx'
    try:
        data = pd.read_excel(file_name, sheet_name='Hoja1')
    except FileNotFoundError:
        print(f"Error: No se encontró el archivo {file_name}. Asegúrate de que esté en la misma carpeta.")
        exit()

    # Preparar nodos y enlaces
    nodos = data['Website'].tolist()
    enlaces = []
    for idx, row in data.iterrows():
        cited_by = [int(x) - 1 for x in row['Cited by'].split(',')]
        for c in cited_by:
            enlaces.append((idx, c))

    # Crear la red
    red = Red(nodos, enlaces)

    # Calcular el PageRank para tres valores de d
    resultados = {}
    for d in [0.5, 0.85, 1.0]:
        resultados[f'd={d}'] = pagerank_con_teletransporte(red.P, d=d)

    # Exportar resultados a un archivo CSV
    output = pd.DataFrame({'Página': nodos})
    for d, pi in resultados.items():
        output[d] = pi
    output.to_csv('pagerank_resultados.csv', index=False)

    # Mostrar resultados en consola
    print("\nResultados exportados a 'pagerank_resultados.csv'.")
    for d, pi in resultados.items():
        print(f"\nPageRank con {d}:")
        for nodo, valor in zip(nodos, pi):
            print(f"π para {nodo}: {valor:.4f}")

